[
  {
    "id": "seed_task_1",
    "USER COMMAND": "generate behavior tree for a robot to navigate a maze and collect items",
    "INSTRUCTIONS": "Use only the following behaviors to generate XML Behavior tree based on the user command: {'move_forward': 'Action node: Move the robot one step forward in the current direction.\nReturns: True if the robot can move forward, False otherwise.', 'turn_left': 'Action node: Turn the robot 90 degrees to the left.\nReturns: Always returns True.', 'turn_right': 'Action node: Turn the robot 90 degrees to the right.\nReturns: Always returns True.', 'collect_item': 'Action node: Collect an item at the current location if one exists.\nReturns: True if an item was collected, False otherwise.', 'is_at_exit': 'Condition node: Check if the robot is at the exit of the maze.\nReturns: True if at the exit, False otherwise.', 'is_item_ahead': 'Condition node: Check if there is an item in the next cell in the current direction.\nReturns: True if an item is ahead, False otherwise.'} to construct a behavior tree in XML format for the given command.",
    "INSTANCES": [
      {
        "INPUT": "Navigate a maze and collect all items",
        "OUTPUT": "<BehaviorTree><Sequence><Condition>is_at_exit</Condition><Selector><Sequence><Condition>is_item_ahead</Condition><Action>collect_item</Action></Sequence><Sequence><Action>move_forward</Action><Selector><Action>turn_left</Action><Action>turn_right</Action></Selector></Sequence></Selector></Sequence>\n</BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_2",
    "USER COMMAND": "generate behavior tree for a delivery robot to pick up and drop off packages",
    "INSTRUCTIONS": "Use only the following behaviors to generate XML Behavior tree based on the user command: {'move_to_pickup': 'Action node: Move the robot to the pickup location.\nReturns: True if the robot reached the pickup location, False otherwise.', 'pickup_package': 'Action node: Pick up a package at the current location.\nReturns: True if a package was picked up, False otherwise.', 'move_to_dropoff': 'Action node: Move the robot to the dropoff location.\nReturns: True if the robot reached the dropoff location, False otherwise.', 'drop_package': 'Action node: Drop off the package at the current location.\nReturns: True if the package was dropped off successfully, False otherwise.', 'has_package': 'Condition node: Check if the robot is currently carrying a package.\nReturns: True if the robot has a package, False otherwise.', 'at_pickup': 'Condition node: Check if the robot is at the pickup location.\nReturns: True if at the pickup location, False otherwise.', 'at_dropoff': 'Condition node: Check if the robot is at the dropoff location.\nReturns: True if at the dropoff location, False otherwise.'} to construct a behavior tree in XML format for the given command.",
    "INSTANCES": [
      {
        "INPUT": "Pick up a package and drop it off at the destination",
        "OUTPUT": "<BehaviorTree><Sequence><Selector><Sequence><Condition>at_pickup</Condition><Condition>has_package</Condition><Action>move_to_dropoff</Action><Action>drop_package</Action></Sequence><Sequence><Condition>at_pickup</Condition><Action>pickup_package</Action><Action>move_to_dropoff</Action></Sequence><Action>move_to_pickup</Action></Selector></Sequence>\n</BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_3",
    "USER COMMAND": "generate behavior tree for a robot to clean a room",
    "INSTRUCTIONS": "Use only the following behaviors to generate XML Behavior tree based on the user command: {'move_to_next_area': 'Action node: Move the robot to the next uncleaned area in the room.\nReturns: True if the robot successfully moved to the next area, False otherwise.', 'clean_area': 'Action node: Clean the current area the robot is in.\nReturns: True if the area was cleaned successfully, False otherwise.', 'is_room_clean': 'Condition node: Check if the entire room has been cleaned.\nReturns: True if the room is clean, False otherwise.', 'is_area_dirty': 'Condition node: Check if the current area the robot is in needs cleaning.\nReturns: True if the area is dirty, False otherwise.'} to construct a behavior tree in XML format for the given command.",
    "INSTANCES": [
      {
        "INPUT": "Clean the entire room",
        "OUTPUT": "<BehaviorTree><Sequence><Condition>is_room_clean</Condition><Selector><Sequence><Condition>is_area_dirty</Condition><Action>clean_area</Action></Sequence><Action>move_to_next_area</Action></Selector></Sequence>\n</BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_4",
    "USER COMMAND": "generate behavior tree for a robot to explore an unknown environment and map it",
    "INSTRUCTIONS": "Use only the following behaviors to generate XML Behavior tree based on the user command: {'move_forward': 'Action node: Move the robot one step forward in the current direction.\nReturns: True if the robot can move forward, False otherwise.', 'turn_left': 'Action node: Turn the robot 90 degrees to the left.\nReturns: Always returns True.', 'turn_right': 'Action node: Turn the robot 90 degrees to the right.\nReturns: Always returns True.', 'update_map': 'Action node: Update the robot's internal map of the environment based on its current location and sensor readings.\nReturns: True if the map was updated successfully, False otherwise.', 'is_path_blocked': 'Condition node: Check if the path in the current direction is blocked or impassable.\nReturns: True if the path is blocked, False otherwise.', 'is_area_mapped': 'Condition node: Check if the current area has already been mapped and explored.\nReturns: True if the area is mapped, False otherwise.'} to construct a behavior tree in XML format for the given command.",
    "INSTANCES": [
      {
        "INPUT": "Explore an unknown area and create a map of it",
        "OUTPUT": "<BehaviorTree><Sequence><Condition>is_area_mapped</Condition><Selector><Sequence><Condition>is_path_blocked</Condition><Selector><Action>turn_left</Action><Action>turn_right</Action></Selector></Sequence><Sequence><Action>move_forward</Action><Action>update_map</Action></Sequence></Selector></Sequence>\n</BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_5",
    "USER COMMAND": "generate behavior tree for a robot to assist in a search and rescue operation",
    "INSTRUCTIONS": "Use only the following behaviors to generate XML Behavior tree based on the user command: {'move_to_next_area': 'Action node: Move the robot to the next unsearched area.\nReturns: True if the robot successfully moved to the next area, False otherwise.', 'scan_for_survivors': 'Action node: Scan the current area for any survivors using sensors.\nReturns: True if one or more survivors were detected, False otherwise.', 'mark_area_searched': 'Action node: Mark the current area as searched so it is not revisited.\nReturns: Always returns True.', 'is_search_complete': 'Condition node: Check if the entire search area has been fully searched.\nReturns: True if the search is complete, False otherwise.', 'is_survivor_detected': 'Condition node: Check if a survivor has been detected in the current area.\nReturns: True if a survivor is detected, False otherwise.'}  to construct a behavior tree in XML format for the given command.",
    "INSTANCES": [
      {
        "INPUT": "Search an area and locate any survivors",
        "OUTPUT": "<BehaviorTree><Sequence><Condition>is_search_complete</Condition><Sequence><Action>move_to_next_area</Action><Action>scan_for_survivors</Action><Selector><Sequence><Condition>is_survivor_detected</Condition><Action>call_for_rescue</Action></Sequence><Action>mark_area_searched</Action></Selector></Sequence></Sequence>\n</BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_6",
    "USER COMMAND": "generate behavior tree for a robot to patrol an area and report any intruders",
    "INSTRUCTIONS": "Use only the following behaviors to generate XML Behavior tree based on the user command: {'move_to_next_waypoint': 'Action node: Move the robot to the next waypoint in the patrol route.\nReturns: True if the robot successfully moved to the next waypoint, False otherwise.', 'scan_for_intruders': 'Action node: Scan the current area for any intruders using sensors.\nReturns: True if one or more intruders were detected, False otherwise.', 'report_intruder': 'Action node: Send an alert signal indicating an intruder has been detected.\nReturns: Always returns True.', 'is_patrol_complete': 'Condition node: Check if the robot has completed patrolling the entire area.\nReturns: True if the patrol is complete, False otherwise.'} to construct a behavior tree in XML format for the given command.",
    "INSTANCES": [
      {
        "INPUT": "Patrol an area and report any intruders found",
        "OUTPUT": "<BehaviorTree><Sequence><Condition>is_patrol_complete</Condition><Sequence><Action>move_to_next_waypoint</Action><Action>scan_for_intruders</Action><Selector><Action>report_intruder</Action><Action>wait</Action></Selector></Sequence></Sequence>\n</BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_7",
    "USER COMMAND": "Move forward and then turn left.",
    "INSTRUCTIONS": "Use the following behaviors to generate XML Behavior tree based on the user command: move_forward: Action node - Moves the agent forward. turn_left: Action node - Turns the agent left by 90 degrees.",
    "INSTANCES": [
      {
        "INPUT": "Move forward and then turn left.",
        "OUTPUT": "<BehaviorTree><Sequence><Action>move_forward</Action><Action>turn_left</Action></Sequence></BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_8",
    "USER COMMAND": "If an enemy is near, attack it. Otherwise, move forward.",
    "INSTRUCTIONS": "Use the following behaviors to generate XML Behavior tree based on the user command: is_enemy_near: Condition node - Checks if an enemy is within a certain range. attack: Action node - Makes the agent attack the nearest enemy. move_forward: Action node (same as before).",
    "INSTANCES": [
      {
        "INPUT": "If an enemy is near, attack it. Otherwise, move forward.",
        "OUTPUT": "<BehaviorTree><Selector><Sequence><Condition>is_enemy_near</Condition><Action>attack</Action></Sequence><Action>move_forward</Action></Selector></BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_9",
    "USER COMMAND": "Keep moving forward until reaching a specific location.",
    "INSTRUCTIONS": "Use the following behaviors to generate XML Behavior tree based on the user command: move_forward: Action node (same as before). is_at_location: Condition node - Checks if the agent is at the target location.",
    "INSTANCES": [
      {
        "INPUT": "Keep moving forward until reaching a specific location.",
        "OUTPUT": "<BehaviorTree><Sequence><Condition>is_at_location</Condition><Action>move_forward</Action></Sequence></BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_10",
    "USER COMMAND": "Search for an item and pick it up if found.",
    "INSTRUCTIONS": "Use the following behaviors to generate XML Behavior tree based on the user command: search_for_item: Subtree node - Represents a behavior tree for searching functionality. pick_up_item: Action node - Makes the agent pick up the found item.",
    "INSTANCES": [
      {
        "INPUT": "Search for an item and pick it up if found.",
        "OUTPUT": "<BehaviorTree><Sequence><Action>search_for_item</Action><Condition>is_item_found</Condition><Action>pick_up_item</Action></Sequence></BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_11",
    "USER COMMAND": "Move forward while keeping an eye on health. If health drops below a threshold, find health and restore it.",
    "INSTRUCTIONS": "Use the following behaviors to generate XML Behavior tree based on the user command: move_forward: Action node (same as before). monitor_health: Action node - Continuously checks the agent's health. get_health_pack: Subtree node - Represents a behavior tree for finding health packs. restore_health: Action node - Makes the agent use a health pack to restore health. is_health_low: Condition node - Checks if health is below a specific threshold.",
    "INSTANCES": [
      {
        "INPUT": "Move forward while keeping an eye on health. If health drops below a threshold, find health and restore it.",
        "OUTPUT": "<BehaviorTree><Selector><Sequence><Action>move_forward</Action></Sequence><Sequence><Action>monitor_health</Action><Selector><Sequence><Condition>is_health_low</Condition><Action>get_health_pack</Action><Action>restore_health</Action></Sequence></Selector></Sequence></Selector></BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_12",
    "USER COMMAND": "Explore the environment. If an enemy is found, attack it with a 70% chance. Otherwise, keep exploring.",
    "INSTRUCTIONS": "Use the following behaviors to generate XML Behavior tree based on the user command: explore: Action node - Makes the agent explore the environment. attack: Action node (same as before). is_enemy_near: Condition node (same as before). random_float: Function node - Generates a random number between 0 and 1.",
    "INSTANCES": [
      {
        "INPUT": "Explore the environment. If an enemy is found, attack it with a 70% chance. Otherwise, keep exploring.",
        "OUTPUT": "<BehaviorTree><Selector><Sequence><Condition>is_enemy_near</Condition><Sequence><Action>random_float</Action><Condition>greater_than 0.7</Condition><Action>attack</Action></Sequence></Sequence><Action>explore</Action></Selector></BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_13",
    "USER COMMAND": "Open a door. If it fails, keep trying until successful.",
    "INSTRUCTIONS": "Use the following behaviors to generate XML Behavior tree based on the user command: open_door: Action node - Makes the agent attempt to open a door. is_door_open: Condition node - Checks if the door is open.",
    "INSTANCES": [
      {
        "INPUT": "Open a door. If it fails, keep trying until successful.",
        "OUTPUT": "<BehaviorTree><Sequence><Sequence><Action>open_door</Action><Condition>is_door_open</Condition></Sequence></Sequence></BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_14",
    "USER COMMAND": "Move forward unless an obstacle is detected. If an obstacle is there, avoid it and resume moving forward.",
    "INSTRUCTIONS": "Use the following behaviors to generate XML Behavior tree based on the user command: move_forward: Action node (same as before). is_obstacle_detected: Condition node - Checks if there's an obstacle in the path. avoid_obstacle: Subtree node - Represents a behavior tree for obstacle avoidance logic.",
    "INSTANCES": [
      {
        "INPUT": "Move forward unless an obstacle is detected. If an obstacle is there, avoid it and resume moving forward.",
        "OUTPUT": "<BehaviorTree><Sequence><Selector><Condition>is_obstacle_detected</Condition><Action>avoid_obstacle</Sequence><Action>move_forward</Action></Sequence></BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_15",
    "USER COMMAND": "Patrol a designated area. If health falls below a threshold, find health and restore it before resuming patrol.",
    "INSTRUCTIONS": "Use the following behaviors to generate XML Behavior tree based on the user command: patrol_area: Subtree node (same as before). monitor_health: Action node (same as before). get_health_pack: Subtree node (same as before). restore_health: Action node (same as before). is_health_low: Condition node (same as before).",
    "INSTANCES": [
      {
        "INPUT": "Patrol a designated area. If health falls below a threshold, find health and restore it before resuming patrol.",
        "OUTPUT": "<BehaviorTree><Sequence><Action>patrol_area</Action><Selector><Sequence><Action>monitor_health</Action><Condition>is_health_low</Condition><Sequence><Action>get_health_pack</Action><Action>restore_health</Action></Sequence></Sequence></Sequence></BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_16",
    "USER COMMAND": "If an ally is nearby, share information about nearby enemies.",
    "INSTRUCTIONS": "Use the following behaviors to generate XML Behavior tree based on the user command: is_ally_near: Condition node - Checks if an ally is within a certain range. share_enemy_info: Action node - Makes the agent share information about detected enemies with allies. get_enemy_info: Subtree node - Represents a behavior tree for gathering enemy information.",
    "INSTANCES": [
      {
        "INPUT": "If an ally is nearby, share information about nearby enemies.",
        "OUTPUT": "<BehaviorTree><Sequence><Condition>is_ally_near</Condition><Sequence><Action>get_enemy_info</Action><Action>share_enemy_info</Action></Sequence></Sequence>"
      }
    ]
  },
  {
    "id": "seed_task_17",
    "USER COMMAND": "Go to the last visited location and guard it.",
    "INSTRUCTIONS": "Use the following behaviors to generate XML Behavior tree based on the user command: go_to_location: Action node - Makes the agent move to a specific location. guard_location: Subtree node - Represents a behavior tree for guarding a location. get_last_visited_location: Function node - Retrieves the agent's last visited location from memory.",
    "INSTANCES": [
      {
        "INPUT": "Go to the last visited location and guard it.",
        "OUTPUT": "<BehaviorTree><Sequence><Action>get_last_visited_location</Action><Action>go_to_location</Action><Action>guard_location</Action></Sequence>"
      }
    ]
  },
  {
    "id": "seed_task_18",
    "USER COMMAND": "If ammo is low, find ammo and reload. Otherwise, keep attacking enemies.",
    "INSTRUCTIONS": "Use the following behaviors to generate XML Behavior tree based on the user command: attack: Action node (same as before). reload: Action node - Makes the agent reload its weapon. get_ammo: Subtree node - Represents a behavior tree for finding ammo. is_ammo_low: Condition node - Checks if ammo is below a specific threshold.",
    "INSTANCES": [
      {
        "INPUT": "If ammo is low, find ammo and reload. Otherwise, keep attacking enemies.",
        "OUTPUT": "<BehaviorTree><Selector><Sequence><Condition>is_ammo_low</Condition><Sequence><Action>get_ammo</Action><Action>reload</Action></Sequence></Sequence><Action>attack</Action></Selector></BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_19",
    "USER COMMAND": "Patrol the area. If a low health event is triggered, find health and restore it before resuming patrol.",
    "INSTRUCTIONS": "Use the following behaviors to generate XML Behavior tree based on the user command: patrol_area: Subtree node (same as before). get_health_pack: Subtree node (same as before). restore_health: Action node (same as before). on_low_health: Event node - Triggers when the agent's health falls below a threshold.",
    "INSTANCES": [
      {
        "INPUT": "Patrol the area. If a low health event is triggered, find health and restore it before resuming patrol.",
        "OUTPUT": "<BehaviorTree><Sequence><Action>patrol_area</Action><Sequence><Trigger>on_low_health</Trigger><Sequence><Action>get_health_pack</Action><Action>restore_health</Action></Sequence></Sequence></BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_20",
    "USER COMMAND": "Choose between exploring for resources and attacking enemies based on their urgency.",
    "INSTRUCTIONS": "Use the following behaviors to generate XML Behavior tree based on the user command: explore: Action node (same as before). attack: Action node (same as before). get_resource_urgency: Function node - Calculates the urgency of acquiring resources. get_enemy_threat: Function node - Calculates the threat level of nearby enemies. utility_score: Function node - Combines resource urgency and enemy threat into a single score.",
    "INSTANCES": [
      {
        "INPUT": "Choose between exploring for resources and attacking enemies based on their urgency.",
        "OUTPUT": "<BehaviorTree><Selector><Sequence><Action>get_resource_urgency</Action><Condition>greater_than enemy_threat</Condition><Action>explore</Action></Sequence><Action>attack</Action></Selector></BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_21",
    "USER COMMAND": "Deliver a package to a specific location marked on the blackboard.",
    "INSTRUCTIONS": "Use the following behaviors to generate XML Behavior tree based on the user command: go_to_location: Action node (same as before). deliver_package: Action node - Makes the agent deliver the package at the target location. get_delivery_location: Blackboard key selector - Retrieves the delivery location stored on the blackboard.",
    "INSTANCES": [
      {
        "INPUT": "Deliver a package to a specific location marked on the blackboard.",
        "OUTPUT": "<BehaviorTree><Sequence><Action>get_delivery_location</Action><Action>go_to_location</Action><Action>deliver_package</Action></Sequence>"
      }
    ]
  },
  {
    "id": "seed_task_22",
    "USER COMMAND": "Search for a specific item. If found, pick it up and return to the starting location.",
    "INSTRUCTIONS": "Use the following behaviors to generate XML Behavior tree based on the user command: search_for_item: Subtree node - Represents a behavior tree for searching a specific item. pick_up_item: Action node (same as before). return_to_start: Subtree node - Represents a behavior tree for returning to the starting location.",
    "INSTANCES": [
      {
        "INPUT": "Search for a specific item. If found, pick it up and return to the starting location.",
        "OUTPUT": "<BehaviorTree><Sequence><Action>search_for_item</Action><Condition>is_item_found</Condition><Sequence><Action>pick_up_item</Action><Action>return_to_start</Action></Sequence></Sequence>"
      }
    ]
  },
  {
    "id": "seed_task_23",
    "USER COMMAND": "If a specific door is open, proceed through it. Otherwise, try to open it.",
    "INSTRUCTIONS": "Use the following behaviors to generate XML Behavior tree based on the user command: go_through_door: Action node - Makes the agent go through a specific door. open_door: Action node (same as before). is_door_open: Condition node (same as before). get_door_id: Function node - Retrieves the ID of the specific door to interact with.",
    "INSTANCES": [
      {
        "INPUT": "If a specific door is open, proceed through it. Otherwise, try to open it.",
        "OUTPUT": "<BehaviorTree><Sequence><Action>get_door_id</Action><Selector><Condition>is_door_open</Condition><Action>go_through_door</Sequence><Action>open_door</Action></Selector></Sequence>"
      }
    ]
  },
  {
    "id": "seed_task_24",
    "USER COMMAND": "If carrying a heavy object, move slowly. Otherwise, move at normal speed.",
    "INSTRUCTIONS": "Use the following behaviors to generate XML Behavior tree based on the user command: move_slow: Action node - Makes the agent move at a slow speed. move_normal: Action node - Makes the agent move at a normal speed. is_carrying_heavy_object: Condition node - Checks if the agent is carrying a heavy object (obtained from the environment or game state).",
    "INSTANCES": [
      {
        "INPUT": "If carrying a heavy object, move slowly. Otherwise, move at normal speed.",
        "OUTPUT": "<BehaviorTree><Selector><Condition>is_carrying_heavy_object</Condition><Action>move_slow</Action><Action>move_normal</Action></Selector></BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_25",
    "USER COMMAND": "generate behavior tree to 'Move forward and then turn left.'",
    "INSTRUCTIONS": "Use only the following behaviors to generate XML Behavior tree based on the user command: {move_forward: 'Action node: Move the agent forward.\nReturns: Always returns True, indicating the action was executed.', turn_left: 'Action node: Turn the agent to the left.\nReturns: Always returns True, indicating the action was executed.'} to construct a behavior tree in XML format to the following command.",
    "INSTANCES": [
      {
        "INPUT": "Move forward and then turn left.",
        "OUTPUT": "<BehaviorTree><Sequence><Action>move_forward</Action><Action>turn_left</Action></Sequence>\n</BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_26",
    "USER COMMAND": "generate behavior tree to 'Move forward, detect obstacle, and stop.'",
    "INSTRUCTIONS": "Use only the following behaviors to generate XML Behavior tree based on the user command: {move_forward: 'Action node: Move the agent forward.\nReturns: Always returns True, indicating the action was executed.', detect_obstacle: 'Condition node: Check if there is an obstacle in front.\nReturns: True if obstacle detected, otherwise False.', stop: 'Action node: Stop the agent's movement.\nReturns: Always returns True, indicating the action was executed.'} to construct a behavior tree in XML format to the following command.",
    "INSTANCES": [
      {
        "INPUT": "Move forward, detect obstacle, and stop.",
        "OUTPUT": "<BehaviorTree><Sequence><Action>move_forward</Action><Condition>detect_obstacle</Condition><Action>stop</Action></Sequence>\n</BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_27",
    "USER COMMAND": "generate behavior tree to 'Scan area, if clear move forward, otherwise stop.'",
    "INSTRUCTIONS": "Use only the following behaviors to generate XML Behavior tree based on the user command: {scan_area: 'Action node: Scan the surrounding area.\nReturns: Always returns True, indicating the action was executed.', is_area_clear: 'Condition node: Check if the area is clear.\nReturns: True if area is clear, otherwise False.', move_forward: 'Action node: Move the agent forward.\nReturns: Always returns True, indicating the action was executed.', stop: 'Action node: Stop the agent's movement.\nReturns: Always returns True, indicating the action was executed.'} to construct a behavior tree in XML format to the following command.",
    "INSTANCES": [
      {
        "INPUT": "Scan area, if clear move forward, otherwise stop.",
        "OUTPUT": "<BehaviorTree><Sequence><Action>scan_area</Action><Selector><Sequence><Condition>is_area_clear</Condition><Action>move_forward</Action></Sequence><Action>stop</Action></Selector></Sequence>\n</BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_28",
    "USER COMMAND": "generate behavior tree to 'Patrol area, if intruder detected, sound alarm and stop.'",
    "INSTRUCTIONS": "Use only the following behaviors to generate XML Behavior tree based on the user command: {patrol_area: 'Action node: Patrol the assigned area.\nReturns: Always returns True, indicating the action was executed.', detect_intruder: 'Condition node: Check if there is an intruder.\nReturns: True if intruder detected, otherwise False.', sound_alarm: 'Action node: Sound the alarm.\nReturns: Always returns True, indicating the action was executed.', stop: 'Action node: Stop the agent's movement.\nReturns: Always returns True, indicating the action was executed.'} to construct a behavior tree in XML format to the following command.",
    "INSTANCES": [
      {
        "INPUT": "Patrol area, if intruder detected, sound alarm and stop.",
        "OUTPUT": "<BehaviorTree><Sequence><Action>patrol_area</Action><Condition>detect_intruder</Condition><Action>sound_alarm</Action><Action>stop</Action></Sequence>\n</BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_29",
    "USER COMMAND": "generate behavior tree to 'Move to target, pick up object, and return to base.'",
    "INSTRUCTIONS": "Use only the following behaviors to generate XML Behavior tree based on the user command: {move_to_target: 'Action node: Move the agent to the target location.\nReturns: Always returns True, indicating the action was executed.', pick_up_object: 'Action node: Pick up the object at the target location.\nReturns: Always returns True, indicating the action was executed.', return_to_base: 'Action node: Return the agent to the base.\nReturns: Always returns True, indicating the action was executed.'} to construct a behavior tree in XML format to the following command.",
    "INSTANCES": [
      {
        "INPUT": "Move to target, pick up object, and return to base.",
        "OUTPUT": "<BehaviorTree><Sequence><Action>move_to_target</Action><Action>pick_up_object</Action><Action>return_to_base</Action></Sequence>\n</BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_30",
    "USER COMMAND": "generate behavior tree to 'Move to target, if object present, pick up object, else search area.'",
    "INSTRUCTIONS": "Use only the following behaviors to generate XML Behavior tree based on the user command: {move_to_target: 'Action node: Move the agent to the target location.\nReturns: Always returns True, indicating the action was executed.', is_object_present: 'Condition node: Check if the object is present at the target location.\nReturns: True if object is present, otherwise False.', pick_up_object: 'Action node: Pick up the object at the target location.\nReturns: Always returns True, indicating the action was executed.', search_area: 'Action node: Search the surrounding area for the object.\nReturns: Always returns True, indicating the action was executed.'} to construct a behavior tree in XML format to the following command.",
    "INSTANCES": [
      {
        "INPUT": "Move to target, if object present, pick up object, else search area.",
        "OUTPUT": "<BehaviorTree><Sequence><Action>move_to_target</Action><Selector><Sequence><Condition>is_object_present</Condition><Action>pick_up_object</Action></Sequence><Action>search_area</Action></Selector></Sequence>\n</BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_31",
    "USER COMMAND": "generate behavior tree to 'Patrol area, if fire detected, extinguish fire, return to patrol.'",
    "INSTRUCTIONS": "Use only the following behaviors to generate XML Behavior tree based on the user command: {patrol_area: 'Action node: Patrol the assigned area.\nReturns: Always returns True, indicating the action was executed.', detect_fire: 'Condition node: Check if there is a fire in the area.\nReturns: True if fire detected, otherwise False.', extinguish_fire: 'Action node: Extinguish the detected fire.\nReturns: Always returns True, indicating the action was executed.'} to construct a behavior tree in XML format to the following command.",
    "INSTANCES": [
      {
        "INPUT": "Patrol area, if fire detected, extinguish fire, return to patrol.",
        "OUTPUT": "<BehaviorTree><Sequence><Action>patrol_area</Action><Selector><Sequence><Condition>detect_fire</Condition><Action>extinguish_fire</Action><Action>patrol_area</Action></Sequence><Action>patrol_area</Action></Selector></Sequence>\n</BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_32",
    "USER COMMAND": "generate behavior tree to 'Move to waypoint, scan for signals, if signal found, log signal and move to next waypoint.'",
    "INSTRUCTIONS": "Use only the following behaviors to generate XML Behavior tree based on the user command: {move_to_waypoint: 'Action node: Move the agent to the designated waypoint.\nReturns: Always returns True, indicating the action was executed.', scan_for_signals: 'Action node: Scan the surrounding area for signals.\nReturns: Always returns True, indicating the action was executed.', is_signal_found: 'Condition node: Check if any signal is found.\nReturns: True if signal is found, otherwise False.', log_signal: 'Action node: Log the detected signal.\nReturns: Always returns True, indicating the action was executed.'} to construct a behavior tree in XML format to the following command.",
    "INSTANCES": [
      {
        "INPUT": "Move to waypoint, scan for signals, if signal found, log signal and move to next waypoint.",
        "OUTPUT": "<BehaviorTree><Sequence><Action>move_to_waypoint</Action><Action>scan_for_signals</Action><Selector><Sequence><Condition>is_signal_found</Condition><Action>log_signal</Action></Sequence></Selector><Action>move_to_waypoint</Action></Sequence>\n</BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_33",
    "USER COMMAND": "generate behavior tree to 'Monitor temperature, if temperature exceeds threshold, activate cooling system.'",
    "INSTRUCTIONS": "Use only the following behaviors to generate XML Behavior tree based on the user command: {monitor_temperature: 'Action node: Monitor the current temperature.\nReturns: Always returns True, indicating the action was executed.', is_temperature_exceeded: 'Condition node: Check if the temperature exceeds a predefined threshold.\nReturns: True if temperature exceeds threshold, otherwise False.', activate_cooling_system: 'Action node: Activate the cooling system to reduce the temperature.\nReturns: Always returns True, indicating the action was executed.'} to construct a behavior tree in XML format to the following command.",
    "INSTANCES": [
      {
        "INPUT": "Monitor temperature, if temperature exceeds threshold, activate cooling system.",
        "OUTPUT": "<BehaviorTree><Sequence><Action>monitor_temperature</Action><Selector><Sequence><Condition>is_temperature_exceeded</Condition><Action>activate_cooling_system</Action></Sequence></Selector></Sequence>\n</BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_34",
    "USER COMMAND": "generate behavior tree to 'Explore area, if item found, pick up item, return to base, and log activity.'",
    "INSTRUCTIONS": "Use only the following behaviors to generate XML Behavior tree based on the user command: {explore_area: 'Action node: Explore the surrounding area.\nReturns: Always returns True, indicating the action was executed.', is_item_found: 'Condition node: Check if an item is found in the area.\nReturns: True if item is found, otherwise False.', pick_up_item: 'Action node: Pick up the found item.\nReturns: Always returns True, indicating the action was executed.', return_to_base: 'Action node: Return the agent to the base.\nReturns: Always returns True, indicating the action was executed.', log_activity: 'Action node: Log the activity of finding and picking up the item.\nReturns: Always returns True, indicating the action was executed.'} to construct a behavior tree in XML format to the following command.",
    "INSTANCES": [
      {
        "INPUT": "Explore area, if item found, pick up item, return to base, and log activity.",
        "OUTPUT": "<BehaviorTree><Sequence><Action>explore_area</Action><Selector><Sequence><Condition>is_item_found</Condition><Action>pick_up_item</Action></Sequence></Selector><Action>return_to_base</Action><Action>log_activity</Action></Sequence>\n</BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_35",
    "USER COMMAND": "generate behavior tree to 'Find the target and change color to green, then return home and change color to white.'Output only the XML behavior tree without extra text.",
    "INSTRUCTIONS": {
      "agent_movement_freeze": "Action node: Freeze the agent’s movement, typically to indicate a stop in activity or end of tasks. Returns: Always returns True, indicating the action was executed.",
      "avoid_obstacle": "Action node: Execute an action to avoid detected obstacles. Returns: Always returns True, indicating the action was executed.",
      "change_color_to_green": "Action node: Change the agent’s color to green, usually indicating a successful operation or state. Returns: Always returns True, indicating the action was executed.",
      "change_color_to_white": "Action node: Change the agent’s color to white, usually indicating a neutral or initial state. Returns: Always returns True, indicating the action was executed.",
      "continue_movement_agent": "Action node: Continue the agent’s movement after it has been previously frozen. Returns: Always returns True, indicating the action was executed.",
      "form_line": "Action node: Direct the agent to form a line towards the center of the window. This function adjusts the agent’s position to align it with the center. Returns: Always returns True, indicating the action was executed.",
      "is_agent_in_nest": "Condition node: Determine if the agent is in the nest. Returns: True if the agent is in the nest, False otherwise.",
      "is_line_formed": "Condition node: Determine if the agent has formed a line with a reference point at the center of the window. Returns: True if the line is formed with the center, False otherwise.",
      "is_obstacle_detected": "Condition node: Determine if any obstacles are detected in the vicinity of the agent. Returns: True if an obstacle is detected, False otherwise.",
      "is_path_clear": "Condition node: Check if the path ahead of the agent is clear of obstacles. Returns: True if no obstacles are detected ahead, False if obstacles are present.",
      "is_target_detected": "Action node: Check if the target is within a detectable distance from the agent’s position. Returns: True if the target is within 20 units of distance, False otherwise.",
      "is_target_reached": "Condition node: Check if the agent has reached the target. Returns: True if the target is within 15 units of distance, False otherwise.",
      "task_completed": "Action node: Signal that the agent has completed its designated task by freezing movement and updating state. Returns: Always returns True, indicating that the task completion action was executed.",
      "wander": "Action node: Perform a wandering action where the agent moves randomly within the environment. Returns: Always returns True, indicating the action was executed."
    },
    "INSTANCES": [
      {
        "INPUT": "Find the target and change color to green, then return home and change color to white.",
        "OUTPUT": "<BehaviorTree><Sequence><Selector><Sequence><Condition>is_target_detected</Condition><Action>change_color_to_green</Action><Action>task_completed</Action></Sequence><Action>wander</Action></Selector><Sequence><Condition>is_agent_in_nest</Condition><Action>change_color_to_white</Action></Sequence></Sequence></BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_36",
    "USER COMMAND": "generate behavior tree to 'Find food and change color to green, then return to the nest, change color to white, and freeze movement.'Output only the XML behavior tree without extra text.",
    "INSTRUCTIONS": {
      "agent_movement_freeze": "Action node: Freeze the agent’s movement, typically to indicate a stop in activity or end of tasks. Returns: Always returns True, indicating the action was executed.",
      "avoid_obstacle": "Action node: Execute an action to avoid detected obstacles. Returns: Always returns True, indicating the action was executed.",
      "change_color_to_green": "Action node: Change the agent’s color to green, usually indicating a successful operation or state. Returns: Always returns True, indicating the action was executed.",
      "change_color_to_white": "Action node: Change the agent’s color to white, usually indicating a neutral or initial state. Returns: Always returns True, indicating the action was executed.",
      "continue_movement_agent": "Action node: Continue the agent’s movement after it has been previously frozen. Returns: Always returns True, indicating the action was executed.",
      "form_line": "Action node: Direct the agent to form a line towards the center of the window. This function adjusts the agent’s position to align it with the center. Returns: Always returns True, indicating the action was executed.",
      "is_agent_in_nest": "Condition node: Determine if the agent is in the nest. Returns: True if the agent is in the nest, False otherwise.",
      "is_line_formed": "Condition node: Determine if the agent has formed a line with a reference point at the center of the window. Returns: True if the line is formed with the center, False otherwise.",
      "is_obstacle_detected": "Condition node: Determine if any obstacles are detected in the vicinity of the agent. Returns: True if an obstacle is detected, False otherwise.",
      "is_path_clear": "Condition node: Check if the path ahead of the agent is clear of obstacles. Returns: True if no obstacles are detected ahead, False if obstacles are present.",
      "is_target_detected": "Action node: Check if the target is within a detectable distance from the agent’s position. Returns: True if the target is within 20 units of distance, False otherwise.",
      "is_target_reached": "Condition node: Check if the agent has reached the target. Returns: True if the target is within 15 units of distance, False otherwise.",
      "task_completed": "Action node: Signal that the agent has completed its designated task by freezing movement and updating state. Returns: Always returns True, indicating that the task completion action was executed.",
      "wander": "Action node: Perform a wandering action where the agent moves randomly within the environment. Returns: Always returns True, indicating the action was executed."
    },
    "INSTANCES": [
      {
        "INPUT": "Find food and change color to green, then return to the nest, change color to white, and freeze movement.",
        "OUTPUT": "<BehaviorTree> <Sequence> <Selector> <Sequence> <Condition>is_target_detected</Condition> <Action>change_color_to_green</Action> <Action>task_completed</Action> </Sequence> <Action>wander</Action> </Selector> <Sequence> <Condition>is_agent_in_nest</Condition> <Action>change_color_to_white</Action> <Action>agent_movement_freeze</Action> </Sequence> </Sequence> </BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_37",
    "USER COMMAND": "generate behavior tree to 'Detect an obstacle, change color to green, try to find the goal, then change color to white.'Output only the XML behavior tree without extra text.",
    "INSTRUCTIONS": {
      "agent_movement_freeze": "Action node: Freeze the agent’s movement, typically to indicate a stop in activity or end of tasks. Returns: Always returns True, indicating the action was executed.",
      "avoid_obstacle": "Action node: Execute an action to avoid detected obstacles. Returns: Always returns True, indicating the action was executed.",
      "change_color_to_green": "Action node: Change the agent’s color to green, usually indicating a successful operation or state. Returns: Always returns True, indicating the action was executed.",
      "change_color_to_white": "Action node: Change the agent’s color to white, usually indicating a neutral or initial state. Returns: Always returns True, indicating the action was executed.",
      "continue_movement_agent": "Action node: Continue the agent’s movement after it has been previously frozen. Returns: Always returns True, indicating the action was executed.",
      "form_line": "Action node: Direct the agent to form a line towards the center of the window. This function adjusts the agent’s position to align it with the center. Returns: Always returns True, indicating the action was executed.",
      "is_agent_in_nest": "Condition node: Determine if the agent is in the nest. Returns: True if the agent is in the nest, False otherwise.",
      "is_line_formed": "Condition node: Determine if the agent has formed a line with a reference point at the center of the window. Returns: True if the line is formed with the center, False otherwise.",
      "is_obstacle_detected": "Condition node: Determine if any obstacles are detected in the vicinity of the agent. Returns: True if an obstacle is detected, False otherwise.",
      "is_path_clear": "Condition node: Check if the path ahead of the agent is clear of obstacles. Returns: True if no obstacles are detected ahead, False if obstacles are present.",
      "is_target_detected": "Action node: Check if the target is within a detectable distance from the agent’s position. Returns: True if the target is within 20 units of distance, False otherwise.",
      "is_target_reached": "Condition node: Check if the agent has reached the target. Returns: True if the target is within 15 units of distance, False otherwise.",
      "task_completed": "Action node: Signal that the agent has completed its designated task by freezing movement and updating state. Returns: Always returns True, indicating that the task completion action was executed.",
      "wander": "Action node: Perform a wandering action where the agent moves randomly within the environment. Returns: Always returns True, indicating the action was executed."
    },
    "INSTANCES": [
      {
        "INPUT": "Detect an obstacle, change color to green, try to find the goal, then change color to white.",
        "OUTPUT": "<BehaviorTree> <Sequence> <Selector> <Sequence> <Condition>is_obstacle_detected</Condition> <Action>change_color_to_green</Action> </Sequence> <Action>avoid_obstacle</Action> </Selector> <Selector> <Sequence> <Condition>is_target_detected</Condition> <Action>change_color_to_white</Action> <Action>task_completed</Action> </Sequence> <Action>wander</Action> </Selector> </Sequence> </BehaviorTree>"
      }
    ]
  },
  {
    "id": "seed_task_38",
    "USER COMMAND": "generate behavior tree to 'Form a line and then change color to green.'Output only the XML behavior tree without extra text.",
    "INSTRUCTIONS": {
      "agent_movement_freeze": "Action node: Freeze the agent’s movement, typically to indicate a stop in activity or end of tasks. Returns: Always returns True, indicating the action was executed.",
      "avoid_obstacle": "Action node: Execute an action to avoid detected obstacles. Returns: Always returns True, indicating the action was executed.",
      "change_color_to_green": "Action node: Change the agent’s color to green, usually indicating a successful operation or state. Returns: Always returns True, indicating the action was executed.",
      "change_color_to_white": "Action node: Change the agent’s color to white, usually indicating a neutral or initial state. Returns: Always returns True, indicating the action was executed.",
      "continue_movement_agent": "Action node: Continue the agent’s movement after it has been previously frozen. Returns: Always returns True, indicating the action was executed.",
      "form_line": "Action node: Direct the agent to form a line towards the center of the window. This function adjusts the agent’s position to align it with the center. Returns: Always returns True, indicating the action was executed.",
      "is_agent_in_nest": "Condition node: Determine if the agent is in the nest. Returns: True if the agent is in the nest, False otherwise.",
      "is_line_formed": "Condition node: Determine if the agent has formed a line with a reference point at the center of the window. Returns: True if the line is formed with the center, False otherwise.",
      "is_obstacle_detected": "Condition node: Determine if any obstacles are detected in the vicinity of the agent. Returns: True if an obstacle is detected, False otherwise.",
      "is_path_clear": "Condition node: Check if the path ahead of the agent is clear of obstacles. Returns: True if no obstacles are detected ahead, False if obstacles are present.",
      "is_target_detected": "Action node: Check if the target is within a detectable distance from the agent’s position. Returns: True if the target is within 20 units of distance, False otherwise.",
      "is_target_reached": "Condition node: Check if the agent has reached the target. Returns: True if the target is within 15 units of distance, False otherwise.",
      "task_completed": "Action node: Signal that the agent has completed its designated task by freezing movement and updating state. Returns: Always returns True, indicating that the task completion action was executed.",
      "wander": "Action node: Perform a wandering action where the agent moves randomly within the environment. Returns: Always returns True, indicating the action was executed."
    },
    "INSTANCES": [
      {
        "INPUT": "Form a line and then change color to green.",
        "OUTPUT": "<BehaviorTree> <Sequence> <Selector> <Sequence> <Condition>is_line_formed</Condition> <Action>change_color_to_green</Action> <Action>agent_movement_freeze</Action> <Action>task_completed</Action> </Sequence> <Action>form_line</Action> </Selector> </Sequence> </BehaviorTree>"
      }
    ]
  }
]